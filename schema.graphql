directive @loginRequired(withoutTwoFactor: Boolean) on FIELD_DEFINITION

"""Exposes a URL that specifies the behaviour of this scalar."""
directive @specifiedBy(
  """The URL that specifies the behaviour of this scalar."""
  url: String!
) on SCALAR

type AccessmodAccessibilityAnalysis implements AccessmodAnalysis & AccessmodOwnership {
  id: String!
  type: AccessmodAnalysisType!
  status: AccessmodAnalysisStatus!
  name: String!
  owner: AccessmodOwner
  author: User!
  permissions: AccessmodAnalysisPermissions!
  createdAt: DateTime!
  updatedAt: DateTime!
  landCover: AccessmodFileset
  dem: AccessmodFileset
  transportNetwork: AccessmodFileset
  water: AccessmodFileset
  barrier: AccessmodFileset
  stack: AccessmodFileset
  stackPriorities: StackPriorities
  movingSpeeds: MovingSpeeds
  healthFacilities: AccessmodFileset
  invertDirection: Boolean
  maxTravelTime: Int
  waterAllTouched: Boolean
  algorithm: AccessmodAccessibilityAnalysisAlgorithm
  knightMove: Boolean
  travelTimes: AccessmodFileset
  frictionSurface: AccessmodFileset
}

enum AccessmodAccessibilityAnalysisAlgorithm {
  ANISOTROPIC
  ISOTROPIC
}

type AccessmodAccessRequest {
  id: String!
  firstName: String!
  lastName: String!
  email: String!
  acceptedTos: Boolean!
  status: AccessmodAccessRequestStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccessmodAccessRequestPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [AccessmodAccessRequest!]!
}

enum AccessmodAccessRequestStatus {
  PENDING
  APPROVED
  DENIED
}

interface AccessmodAnalysis {
  id: String!
  type: AccessmodAnalysisType!
  status: AccessmodAnalysisStatus!
  name: String!
  author: User!
  permissions: AccessmodAnalysisPermissions!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccessmodAnalysisPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [AccessmodAnalysis!]!
}

type AccessmodAnalysisPermissions {
  update: Boolean!
  delete: Boolean!
  run: Boolean!
}

enum AccessmodAnalysisStatus {
  DRAFT
  READY
  QUEUED
  RUNNING
  SUCCESS
  FAILED
}

enum AccessmodAnalysisType {
  ACCESSIBILITY
  GEOGRAPHIC_COVERAGE
  ZONAL_STATISTICS
}

type AccessmodFile {
  id: String!
  uri: String!
  name: String!
  fileset: AccessmodFileset
  mimeType: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccessmodFileset implements AccessmodOwnership {
  id: String!
  name: String!
  mode: AccessmodFilesetMode!
  status: AccessmodFilesetStatus!
  role: AccessmodFilesetRole!
  author: User!
  owner: AccessmodOwner
  files: [AccessmodFile!]!
  metadata: AccessmodFilesetMetadata!
  permissions: AccessmodFilesetPermissions!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum AccessmodFilesetFormat {
  VECTOR
  RASTER
  TABULAR
}

scalar AccessmodFilesetMetadata

enum AccessmodFilesetMode {
  USER_INPUT
  AUTOMATIC_ACQUISITION
}

type AccessmodFilesetPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [AccessmodFileset!]!
}

type AccessmodFilesetPermissions {
  update: Boolean!
  delete: Boolean!
  createFile: Boolean!
}

type AccessmodFilesetRole {
  id: String!
  code: AccessmodFilesetRoleCode!
  name: String!
  format: AccessmodFilesetFormat!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum AccessmodFilesetRoleCode {
  BARRIER
  COVERAGE
  DEM
  FRICTION_SURFACE
  GEOMETRY
  HEALTH_FACILITIES
  LAND_COVER
  POPULATION
  TRANSPORT_NETWORK
  TRAVEL_TIMES
  WATER
  STACK
  BOUNDARIES
  ZONAL_STATISTICS
  ZONAL_STATISTICS_TABLE
}

enum AccessmodFilesetStatus {
  PENDING
  VALIDATING
  VALID
  INVALID
  TO_ACQUIRE
}

type AccessmodGeographicCoverageAnalysis implements AccessmodAnalysis & AccessmodOwnership {
  id: String!
  type: AccessmodAnalysisType!
  status: AccessmodAnalysisStatus!
  name: String!
  owner: AccessmodOwner
  author: User!
  permissions: AccessmodAnalysisPermissions!
  createdAt: DateTime!
  updatedAt: DateTime!
  population: AccessmodFileset
  frictionSurface: AccessmodFileset
  dem: AccessmodFileset
  healthFacilities: AccessmodFileset
  anisotropic: Boolean
  maxTravelTime: Int
  hfProcessingOrder: String
  geographicCoverage: AccessmodFileset
  catchmentAreas: AccessmodFileset
}

union AccessmodOwner = User | Team

interface AccessmodOwnership {
  owner: AccessmodOwner
}

type AccessmodProject implements AccessmodOwnership {
  id: String!
  name: String!
  spatialResolution: Int!
  description: String!
  crs: Int!
  country: Country!
  author: User!
  owner: AccessmodOwner
  extent: [[Float!]!]
  dem: AccessmodFileset
  permissions: AccessmodProjectPermissions!
  members: [AccessmodProjectMember!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccessmodProjectMember {
  id: String!
  user: User
  team: Team
  project: AccessmodProject!
  mode: PermissionMode!
  permissions: AccessmodProjectMemberPermissions!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccessmodProjectMemberPermissions {
  update: Boolean!
  delete: Boolean!
}

enum AccessmodProjectOrder {
  UPDATED_AT_DESC
  UPDATED_AT_ASC
  NAME_DESC
  NAME_ASC
}

type AccessmodProjectPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [AccessmodProject!]!
}

type AccessmodProjectPermissions {
  update: Boolean!
  delete: Boolean!
  createFileset: Boolean!
  createAnalysis: Boolean!
  createMember: Boolean!
  createPermission: Boolean!
}

type AccessmodZonalStatistics implements AccessmodAnalysis & AccessmodOwnership {
  id: String!
  type: AccessmodAnalysisType!
  status: AccessmodAnalysisStatus!
  name: String!
  owner: AccessmodOwner
  author: User!
  permissions: AccessmodAnalysisPermissions!
  createdAt: DateTime!
  updatedAt: DateTime!
  population: AccessmodFileset
  travelTimes: AccessmodFileset
  boundaries: AccessmodFileset
  timeThresholds: TimeThresholds
  zonalStatisticsTable: AccessmodFileset
  zonalStatisticsGeo: AccessmodFileset
}

type Activity {
  description: String!
  occurredAt: DateTime!
  url: URL!
  status: ActivityStatus!
}

enum ActivityStatus {
  SUCCESS
  PENDING
  RUNNING
  ERROR
  UNKNOWN
}

input AddPipelineOutputInput {
  uri: String!
  type: String!
  name: String
}

type AddPipelineOutputResult {
  success: Boolean!
  errors: [PipelineError!]!
}

enum ApproveAccessmodAccessRequestError {
  INVALID
}

input ApproveAccessmodAccessRequestInput {
  id: String!
}

type ApproveAccessmodAccessRequestResult {
  success: Boolean!
  errors: [ApproveAccessmodAccessRequestError!]!
}

enum ArchiveWorkspaceError {
  PERMISSION_DENIED
  NOT_FOUND
}

input ArchiveWorkspaceInput {
  slug: String!
}

type ArchiveWorkspaceResult {
  success: Boolean!
  errors: [ArchiveWorkspaceError!]!
}

type Avatar {
  initials: String!
  color: String!
}

scalar BigInt

type Bucket {
  name: String!
  objects(prefix: String, page: Int = 1, perPage: Int = 15, query: String, ignoreHiddenFiles: Boolean = true): BucketObjectPage!
  object(key: String!): BucketObject
}

type BucketObject {
  key: String!
  name: String!
  path: String!
  size: BigInt
  updatedAt: DateTime
  type: BucketObjectType!
}

type BucketObjectPage {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  pageNumber: Int!
  items: [BucketObject!]!
}

enum BucketObjectType {
  FILE
  DIRECTORY
}

type CatalogEntry {
  id: UUID!
  name: String!
  description: String
  countries: [Country!]!
  lastSyncedAt: DateTime
  symbol: URL
  externalId: String
  externalType: String
  externalSubtype: String
  externalName: String
  externalDescription: String
  type: CatalogEntryType!
  objectId: String!
  objectUrl: URL!
  datasource: Datasource
}

type CatalogEntryType {
  id: UUID!
  app: String!
  model: String!
  name: String!
}

type CatalogPage {
  items: [CatalogEntry!]!
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
}

type Connection {
  id: String!
  name: String!
  slug: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
  type: ConnectionType!
  user: User
  fields: [ConnectionField!]!
  permissions: ConnectionPermissions!
}

type ConnectionField {
  code: String!
  value: String
  secret: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime
}

input ConnectionFieldInput {
  code: String!
  value: String
  secret: Boolean!
}

type ConnectionPermissions {
  update: Boolean!
  delete: Boolean!
}

enum ConnectionType {
  S3
  GCS
  POSTGRESQL
  DHIS2
  CUSTOM
  IASO
}

type Country {
  code: String!
  alpha3: String!
  name: String!
  flag: String!
  whoInfo: WHOInfo!
}

input CountryInput {
  code: String!
  alpha3: String
  name: String
  flag: String
}

enum CreateAccessmodAccessibilityAnalysisError {
  NAME_DUPLICATE
}

input CreateAccessmodAccessibilityAnalysisInput {
  projectId: String!
  name: String!
}

type CreateAccessmodAccessibilityAnalysisResult {
  success: Boolean!
  analysis: AccessmodAccessibilityAnalysis
  errors: [CreateAccessmodAccessibilityAnalysisError!]!
}

enum CreateAccessmodFileError {
  URI_DUPLICATE
}

input CreateAccessmodFileInput {
  filesetId: String!
  uri: String!
  mimeType: String!
}

type CreateAccessmodFileResult {
  success: Boolean!
  file: AccessmodFile
  errors: [CreateAccessmodFileError!]!
}

enum CreateAccessmodFilesetError {
  NAME_DUPLICATE
  PERMISSION_DENIED
}

input CreateAccessmodFilesetInput {
  name: String!
  projectId: String!
  roleId: String!
  automatic: Boolean
  metadata: AccessmodFilesetMetadata
}

type CreateAccessmodFilesetResult {
  success: Boolean!
  fileset: AccessmodFileset
  errors: [CreateAccessmodFilesetError!]!
}

enum CreateAccessmodProjectError {
  NAME_DUPLICATE
  PERMISSION_DENIED
}

input CreateAccessmodProjectInput {
  name: String!
  description: String
  spatialResolution: Int!
  crs: Int!
  country: CountryInput!
  extent: [[Float!]!]
}

enum CreateAccessmodProjectMemberError {
  ALREADY_EXISTS
  PERMISSION_DENIED
  NOT_FOUND
  NOT_IMPLEMENTED
}

input CreateAccessmodProjectMemberInput {
  userId: String
  teamId: String
  projectId: String!
  mode: PermissionMode!
}

type CreateAccessmodProjectMemberResult {
  success: Boolean!
  member: AccessmodProjectMember
  errors: [CreateAccessmodProjectMemberError!]!
}

type CreateAccessmodProjectResult {
  success: Boolean!
  project: AccessmodProject
  errors: [CreateAccessmodProjectError!]!
}

enum CreateAccessmodZonalStatisticsError {
  NAME_DUPLICATE
}

input CreateAccessmodZonalStatisticsInput {
  projectId: String!
  name: String!
}

type CreateAccessmodZonalStatisticsResult {
  success: Boolean!
  analysis: AccessmodZonalStatistics
  errors: [CreateAccessmodZonalStatisticsError!]!
}

enum CreateBucketFolderError {
  ALREADY_EXISTS
  PERMISSION_DENIED
}

input CreateBucketFolderInput {
  workspaceSlug: String!
  folderKey: String!
}

type CreateBucketFolderResult {
  success: Boolean!
  errors: [CreateBucketFolderError!]!
  folder: BucketObject
}

enum CreateConnectionError {
  WORKSPACE_NOT_FOUND
  PERMISSION_DENIED
  INVALID_SLUG
}

input CreateConnectionInput {
  workspaceSlug: String!
  name: String!
  slug: String
  description: String
  type: ConnectionType!
  fields: [ConnectionFieldInput!]
}

type CreateConnectionResult {
  success: Boolean!
  connection: Connection
  errors: [CreateConnectionError!]!
}

enum CreateDatasetError {
  WORKSPACE_NOT_FOUND
  PERMISSION_DENIED
}

input CreateDatasetInput {
  workspaceSlug: String!
  name: String!
  description: String
}

type CreateDatasetResult {
  link: DatasetLink
  dataset: Dataset
  success: Boolean!
  errors: [CreateDatasetError!]!
}

enum CreateDatasetVersionError {
  DATASET_NOT_FOUND
  DUPLICATE_NAME
  PERMISSION_DENIED
}

enum CreateDatasetVersionFileError {
  VERSION_NOT_FOUND
  LOCKED_VERSION
  ALREADY_EXISTS
  INVALID_URI
  PERMISSION_DENIED
}

input CreateDatasetVersionFileInput {
  versionId: ID!
  contentType: String!
  uri: String!
}

type CreateDatasetVersionFileResult {
  file: DatasetVersionFile
  uploadUrl: String
  success: Boolean!
  errors: [CreateDatasetVersionFileError!]!
}

input CreateDatasetVersionInput {
  datasetId: ID!
  name: String!
  description: String
}

type CreateDatasetVersionResult {
  version: DatasetVersion
  success: Boolean!
  errors: [CreateDatasetVersionError!]!
}

enum CreateMembershipError {
  ALREADY_EXISTS
  PERMISSION_DENIED
  NOT_FOUND
}

input CreateMembershipInput {
  userEmail: String!
  teamId: UUID!
  role: MembershipRole!
}

type CreateMembershipResult {
  success: Boolean!
  membership: Membership
  errors: [CreateMembershipError!]!
}

input CreatePipelineInput {
  code: String!
  name: String
  workspaceSlug: String!
}

type CreatePipelineResult {
  success: Boolean!
  errors: [PipelineError!]!
  pipeline: Pipeline
}

enum CreateTeamError {
  PERMISSION_DENIED
  NAME_DUPLICATE
}

input CreateTeamInput {
  name: String!
}

type CreateTeamResult {
  team: Team
  success: Boolean!
  errors: [CreateTeamError!]!
}

enum CreateWorkspaceError {
  PERMISSION_DENIED
  INVALID_SLUG
}

input CreateWorkspaceInput {
  name: String!
  slug: String
  description: String
  countries: [CountryInput!]
  loadSampleData: Boolean
}

type CreateWorkspaceResult {
  success: Boolean!
  errors: [CreateWorkspaceError!]!
  workspace: Workspace
}

type DAG {
  id: UUID!
  label: String!
  tags: [Tag!]!
  formCode: String
  countries: [Country!]!
  externalId: String!
  description: String
  user: User
  template: DAGTemplate!
  schedule: String
  externalUrl: URL
  runs(page: Int, perPage: Int, orderBy: DAGRunOrderBy): DAGRunPage!
}

type DAGPage {
  items: [DAG!]!
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
}

type DAGRun {
  id: UUID!
  label: String
  externalId: String
  externalUrl: URL
  user: User
  config: JSON
  status: DAGRunStatus!
  executionDate: DateTime
  lastRefreshedAt: DateTime
  duration: Int
  progress: Int!
  triggerMode: DAGRunTrigger
  messages: [DAGRunMessage!]!
  logs: String
  outputs: [DAGRunOutput!]!
  isFavorite: Boolean!
}

type DAGRunMessage {
  message: String!
  priority: String!
  timestamp: DateTime
}

enum DAGRunOrderBy {
  EXECUTION_DATE_DESC
  EXECUTION_DATE_ASC
}

type DAGRunOutput {
  title: String!
  uri: String!
}

type DAGRunPage {
  items: [DAGRun!]!
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
}

enum DAGRunStatus {
  success
  running
  failed
  queued
}

enum DAGRunTrigger {
  SCHEDULED
  MANUAL
}

type DAGTemplate {
  code: String!
  description: String
  sampleConfig: JSON
}

type Database {
  tables(page: Int, perPage: Int): DatabaseTablePage!
  table(name: String!): DatabaseTable
  credentials: DatabaseCredentials
}

type DatabaseCredentials {
  dbName: String!
  username: String!
  password: String!
  host: String!
  port: Int!
  url: String!
}

type DatabaseTable {
  name: String!
  count: Int
  columns: [TableColumn!]!
  sample: JSON!
  rows(orderBy: String!, direction: OrderByDirection!, page: Int!, perPage: Int = 15): TableRowsPage!
}

type DatabaseTablePage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [DatabaseTable!]!
}

type Dataset {
  id: ID!
  slug: String!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: User
  workspace: Workspace
  permissions: DatasetPermissions!
  versions(page: Int = 1, perPage: Int = 15): DatasetVersionPage!
  version(id: ID!): DatasetVersion
  latestVersion: DatasetVersion
  links(page: Int = 1, perPage: Int = 15): DatasetLinkPage!
}

type DatasetLink {
  id: ID!
  isPinned: Boolean!
  createdAt: DateTime!
  createdBy: User
  dataset: Dataset!
  workspace: Workspace!
  permissions: DatasetLinkPermissions!
}

type DatasetLinkPage {
  totalPages: Int!
  totalItems: Int!
  pageNumber: Int!
  items: [DatasetLink!]!
}

type DatasetLinkPermissions {
  delete: Boolean!
  pin: Boolean!
}

type DatasetPage {
  totalPages: Int!
  totalItems: Int!
  pageNumber: Int!
  items: [Dataset!]!
}

type DatasetPermissions {
  update: Boolean!
  delete: Boolean!
  createVersion: Boolean!
}

type DatasetVersion {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  createdBy: User
  dataset: Dataset!
  permissions: DatasetVersionPermissions!
  fileByName(name: String!): DatasetVersionFile
  files(page: Int = 1, perPage: Int = 15): DatasetVersionFilePage!
}

type DatasetVersionFile {
  id: ID!
  uri: String!
  filename: String!
  createdAt: DateTime!
  createdBy: User
  contentType: String!
}

type DatasetVersionFilePage {
  totalPages: Int!
  totalItems: Int!
  pageNumber: Int!
  items: [DatasetVersionFile!]!
}

type DatasetVersionPage {
  totalPages: Int!
  totalItems: Int!
  pageNumber: Int!
  items: [DatasetVersion!]!
}

type DatasetVersionPermissions {
  update: Boolean!
  delete: Boolean!
  download: Boolean!
}

type Datasource {
  id: UUID!
  name: String!
}

scalar Date

scalar DateTime

enum DeclineWorkspaceInvitationError {
  INVITATION_NOT_FOUND
  PERMISSION_DENIED
}

input DeclineWorkspaceInvitationInput {
  invitationId: UUID!
}

type DeclineWorkspaceInvitationResult {
  success: Boolean!
  invitation: WorkspaceInvitation
  errors: [DeclineWorkspaceInvitationError!]!
}

enum DeleteAccessmodAnalysisError {
  NOT_FOUND
  DELETE_FAILED
}

input DeleteAccessmodAnalysisInput {
  id: String!
}

type DeleteAccessmodAnalysisResult {
  success: Boolean!
  errors: [DeleteAccessmodAnalysisError!]!
}

enum DeleteAccessmodFilesetError {
  NOT_FOUND
  FILESET_IN_USE
}

input DeleteAccessmodFilesetInput {
  id: String!
}

type DeleteAccessmodFilesetResult {
  success: Boolean!
  errors: [DeleteAccessmodFilesetError!]!
}

enum DeleteAccessmodProjectError {
  NOT_FOUND
  PERMISSION_DENIED
}

input DeleteAccessmodProjectInput {
  id: String!
}

enum DeleteAccessmodProjectMemberError {
  PERMISSION_DENIED
  NOT_FOUND
  NOT_IMPLEMENTED
}

input DeleteAccessmodProjectMemberInput {
  id: String!
}

type DeleteAccessmodProjectMemberResult {
  success: Boolean!
  errors: [DeleteAccessmodProjectMemberError!]!
}

type DeleteAccessmodProjectResult {
  success: Boolean!
  errors: [DeleteAccessmodProjectError!]!
}

enum DeleteBucketObjectError {
  NOT_FOUND
  PERMISSION_DENIED
}

input DeleteBucketObjectInput {
  workspaceSlug: String!
  objectKey: String!
}

type DeleteBucketObjectResult {
  success: Boolean!
  errors: [DeleteBucketObjectError!]!
}

enum DeleteConnectionError {
  NOT_FOUND
  PERMISSION_DENIED
}

input DeleteConnectionInput {
  id: String!
}

type DeleteConnectionResult {
  success: Boolean!
  errors: [DeleteConnectionError!]!
}

enum DeleteDatasetError {
  DATASET_NOT_FOUND
  PERMISSION_DENIED
}

input DeleteDatasetInput {
  id: ID!
}

enum DeleteDatasetLinkError {
  NOT_FOUND
  PERMISSION_DENIED
}

input DeleteDatasetLinkInput {
  id: ID!
}

type DeleteDatasetLinkResult {
  success: Boolean!
  errors: [DeleteDatasetLinkError!]!
}

type DeleteDatasetResult {
  success: Boolean!
  errors: [DeleteDatasetError!]!
}

enum DeleteDatasetVersionError {
  VERSION_NOT_FOUND
  PERMISSION_DENIED
}

input DeleteDatasetVersionInput {
  versionId: ID!
}

type DeleteDatasetVersionResult {
  success: Boolean!
  errors: [DeleteDatasetVersionError!]!
}

enum DeleteMembershipError {
  PERMISSION_DENIED
  NOT_FOUND
}

input DeleteMembershipInput {
  id: UUID!
}

type DeleteMembershipResult {
  success: Boolean!
  errors: [DeleteMembershipError!]!
}

input DeletePipelineInput {
  id: UUID!
}

type DeletePipelineResult {
  success: Boolean!
  errors: [PipelineError!]!
}

enum DeletePipelineVersionError {
  PIPELINE_VERSION_NOT_FOUND
  PERMISSION_DENIED
  PIPELINE_NOT_FOUND
}

input DeletePipelineVersionInput {
  pipelineId: UUID!
  versionId: UUID!
}

type DeletePipelineVersionResult {
  success: Boolean!
  errors: [DeletePipelineVersionError!]!
}

enum DeleteTeamError {
  NOT_FOUND
  PERMISSION_DENIED
}

input DeleteTeamInput {
  id: UUID!
}

type DeleteTeamResult {
  success: Boolean!
  errors: [DeleteTeamError!]!
}

enum DeleteWorkspaceError {
  PERMISSION_DENIED
  NOT_FOUND
}

input DeleteWorkspaceInput {
  slug: String!
}

enum DeleteWorkspaceInvitationError {
  INVITATION_NOT_FOUND
  PERMISSION_DENIED
}

input DeleteWorkspaceInvitationInput {
  invitationId: UUID!
}

type DeleteWorkspaceInvitationResult {
  success: Boolean!
  errors: [DeleteWorkspaceInvitationError!]!
}

enum DeleteWorkspaceMemberError {
  MEMBERSHIP_NOT_FOUND
  PERMISSION_DENIED
}

input DeleteWorkspaceMemberInput {
  membershipId: UUID!
}

type DeleteWorkspaceMemberResult {
  success: Boolean!
  errors: [DeleteWorkspaceMemberError!]!
}

type DeleteWorkspaceResult {
  success: Boolean!
  errors: [DeleteWorkspaceError!]!
}

enum DenyAccessmodAccessRequestError {
  INVALID
}

input DenyAccessmodAccessRequestInput {
  id: String!
}

type DenyAccessmodAccessRequestResult {
  success: Boolean!
  errors: [DenyAccessmodAccessRequestError!]!
}

type DHIS2DataElement {
  id: String!
  name: String!
  code: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  instance: DHIS2Instance!
}

type DHIS2DataElementPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [DHIS2DataElement!]!
}

type DHIS2Instance {
  id: String!
  name: String!
  url: String
}

enum DisableTwoFactorError {
  INVALID_OTP
  NOT_ENABLED
}

input DisableTwoFactorInput {
  token: String!
}

type DisableTwoFactorResult {
  success: Boolean!
  errors: [DisableTwoFactorError!]
}

enum EnableTwoFactorError {
  ALREADY_ENABLED
  EMAIL_MISMATCH
}

input EnableTwoFactorInput {
  email: String
}

type EnableTwoFactorResult {
  success: Boolean!
  verified: Boolean
  errors: [EnableTwoFactorError!]
}

type FeatureFlag {
  code: String!
  config: JSON!
}

enum GenerateChallengeError {
  DEVICE_NOT_FOUND
  CHALLENGE_ERROR
}

type GenerateChallengeResult {
  success: Boolean!
  errors: [GenerateChallengeError!]
}

enum GenerateNewDatabasePasswordError {
  PERMISSION_DENIED
  NOT_FOUND
}

input GenerateNewDatabasePasswordInput {
  workspaceSlug: String!
}

type GenerateNewDatabasePasswordResult {
  success: Boolean!
  errors: [GenerateNewDatabasePasswordError!]!
  workspace: Workspace
}

enum GenerateWorkspaceTokenError {
  WORKSPACE_NOT_FOUND
  PERMISSION_DENIED
}

input GenerateWorkspaceTokenInput {
  slug: String!
}

type GenerateWorkspaceTokenResult {
  success: Boolean!
  token: String
  errors: [GenerateWorkspaceTokenError!]!
}

scalar Generic

type GenericOutput {
  name: String
  type: String!
  uri: String!
}

input InviteWorkspaceMemberInput {
  workspaceSlug: String!
  userEmail: String!
  role: WorkspaceMembershipRole!
}

type InviteWorkspaceMemberResult {
  success: Boolean!
  errors: [InviteWorkspaceMembershipError!]!
  workspaceMembership: WorkspaceMembership
}

enum InviteWorkspaceMembershipError {
  ALREADY_EXISTS
  PERMISSION_DENIED
  USER_NOT_FOUND
  WORKSPACE_NOT_FOUND
}

enum JoinWorkspaceError {
  ALREADY_EXISTS
  ALREADY_ACCEPTED
  PERMISSION_DENIED
  INVITATION_NOT_FOUND
}

input JoinWorkspaceInput {
  invitationId: UUID!
}

type JoinWorkspaceResult {
  success: Boolean!
  workspace: Workspace
  invitation: WorkspaceInvitation
  errors: [JoinWorkspaceError!]!
}

scalar JSON

enum LaunchAccessmodAnalysisError {
  LAUNCH_FAILED
}

input LaunchAccessmodAnalysisInput {
  id: String!
}

type LaunchAccessmodAnalysisResult {
  success: Boolean!
  analysis: AccessmodAnalysis
  errors: [LaunchAccessmodAnalysisError!]!
}

enum LaunchNotebookServerError {
  NOT_FOUND
  PERMISSION_DENIED
}

input LaunchNotebookServerInput {
  workspaceSlug: String!
}

type LaunchNotebookServerResult {
  success: Boolean!
  server: NotebookServer
  errors: [LaunchNotebookServerError!]!
}

enum LinkDatasetError {
  DATASET_NOT_FOUND
  WORKSPACE_NOT_FOUND
  PERMISSION_DENIED
  ALREADY_LINKED
}

input LinkDatasetInput {
  datasetId: ID!
  workspaceSlug: String!
}

type LinkDatasetResult {
  link: DatasetLink
  success: Boolean!
  errors: [LinkDatasetError!]!
}

enum LoginError {
  OTP_REQUIRED
  INVALID_CREDENTIALS
  INVALID_OTP
}

input LoginInput {
  email: String!
  password: String!
  token: String
}

type LoginResult {
  success: Boolean!
  errors: [LoginError!]
}

type LogoutResult {
  success: Boolean!
}

input LogPipelineMessageInput {
  priority: MessagePriority!
  message: String!
}

type LogPipelineMessageResult {
  success: Boolean!
  errors: [PipelineError!]!
}

type Me {
  user: User
  features: [FeatureFlag!]!
  permissions: MePermissions!
  hasTwoFactorEnabled: Boolean!
}

type Membership {
  id: UUID!
  user: User!
  team: Team!
  permissions: MembershipPermissions!
  role: MembershipRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MembershipPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [Membership!]!
}

type MembershipPermissions {
  update: Boolean!
  delete: Boolean!
}

enum MembershipRole {
  ADMIN
  REGULAR
}

type MePermissions {
  createTeam: Boolean!
  adminPanel: Boolean!
  superUser: Boolean!
  createAccessmodProject: Boolean!
  manageAccessmodAccessRequests: Boolean!
  createWorkspace: Boolean!
}

enum MessagePriority {
  DEBUG
  INFO
  WARNING
  ERROR
  CRITICAL
}

scalar MovingSpeeds

type Mutation {
  register(input: RegisterInput!): RegisterResult!
  login(input: LoginInput!): LoginResult!
  logout: LogoutResult!
  resetPassword(input: ResetPasswordInput!): ResetPasswordResult!
  setPassword(input: SetPasswordInput!): SetPasswordResult!
  updateUser(input: UpdateUserInput!): UpdateUserResult!
  verifyDevice(input: VerifyDeviceInput!): VerifyDeviceResult!
  generateChallenge: GenerateChallengeResult!
  enableTwoFactor(input: EnableTwoFactorInput): EnableTwoFactorResult!
  disableTwoFactor(input: DisableTwoFactorInput): DisableTwoFactorResult!
  createTeam(input: CreateTeamInput!): CreateTeamResult!
  updateTeam(input: UpdateTeamInput!): UpdateTeamResult!
  deleteTeam(input: DeleteTeamInput!): DeleteTeamResult!
  createMembership(input: CreateMembershipInput!): CreateMembershipResult!
  updateMembership(input: UpdateMembershipInput!): UpdateMembershipResult!
  deleteMembership(input: DeleteMembershipInput!): DeleteMembershipResult!
  runDAG(input: RunDAGInput!): RunDAGResult!
  updateDAG(input: UpdateDAGInput!): UpdateDAGResult!
  prepareDownloadURL(input: PrepareDownloadURLInput!): PrepareDownloadURLResult
  setDAGRunFavorite(input: SetDAGRunFavoriteInput!): SetDAGRunFavoriteResult
  createAccessmodProject(input: CreateAccessmodProjectInput!): CreateAccessmodProjectResult!
  updateAccessmodProject(input: UpdateAccessmodProjectInput!): UpdateAccessmodProjectResult!
  deleteAccessmodProject(input: DeleteAccessmodProjectInput!): DeleteAccessmodProjectResult!
  createAccessmodProjectMember(input: CreateAccessmodProjectMemberInput!): CreateAccessmodProjectMemberResult!
  updateAccessmodProjectMember(input: UpdateAccessmodProjectMemberInput!): UpdateAccessmodProjectMemberResult!
  deleteAccessmodProjectMember(input: DeleteAccessmodProjectMemberInput!): DeleteAccessmodProjectMemberResult!
  createAccessmodFileset(input: CreateAccessmodFilesetInput!): CreateAccessmodFilesetResult!
  updateAccessmodFileset(input: UpdateAccessmodFilesetInput!): UpdateAccessmodFilesetResult!
  deleteAccessmodFileset(input: DeleteAccessmodFilesetInput!): DeleteAccessmodFilesetResult!
  prepareAccessmodFileUpload(input: PrepareAccessmodFileUploadInput!): PrepareAccessmodFileUploadResult!
  prepareAccessmodFileDownload(input: PrepareAccessmodFileDownloadInput!): PrepareAccessmodFileDownloadResult!
  prepareAccessmodFilesetVisualizationDownload(input: PrepareAccessmodFilesetVisualizationDownloadInput!): PrepareAccessmodFilesetVisualizationDownloadResult!
  createAccessmodFile(input: CreateAccessmodFileInput!): CreateAccessmodFileResult!
  createAccessmodAccessibilityAnalysis(input: CreateAccessmodAccessibilityAnalysisInput): CreateAccessmodAccessibilityAnalysisResult!
  createAccessmodZonalStatistics(input: CreateAccessmodZonalStatisticsInput): CreateAccessmodZonalStatisticsResult!
  updateAccessmodAccessibilityAnalysis(input: UpdateAccessmodAccessibilityAnalysisInput): UpdateAccessmodAccessibilityAnalysisResult!
  updateAccessmodZonalStatistics(input: UpdateAccessmodZonalStatisticsInput): UpdateAccessmodZonalStatisticsResult!
  launchAccessmodAnalysis(input: LaunchAccessmodAnalysisInput): LaunchAccessmodAnalysisResult!
  deleteAccessmodAnalysis(input: DeleteAccessmodAnalysisInput): DeleteAccessmodAnalysisResult!
  requestAccessmodAccess(input: RequestAccessmodAccessInput!): RequestAccessmodAccessInputResult!
  approveAccessmodAccessRequest(input: ApproveAccessmodAccessRequestInput!): ApproveAccessmodAccessRequestResult!
  denyAccessmodAccessRequest(input: DenyAccessmodAccessRequestInput!): DenyAccessmodAccessRequestResult!
  launchNotebookServer(input: LaunchNotebookServerInput!): LaunchNotebookServerResult!
  createPipeline(input: CreatePipelineInput!): CreatePipelineResult!
  updatePipeline(input: UpdatePipelineInput!): UpdatePipelineResult!
  deletePipeline(input: DeletePipelineInput): DeletePipelineResult!
  runPipeline(input: RunPipelineInput): RunPipelineResult!
  pipelineToken(input: PipelineTokenInput): PipelineTokenResult!
  uploadPipeline(input: UploadPipelineInput): UploadPipelineResult!
  logPipelineMessage(input: LogPipelineMessageInput): LogPipelineMessageResult!
  updatePipelineProgress(input: UpdatePipelineProgressInput): UpdatePipelineProgressResult!
  addPipelineOutput(input: AddPipelineOutputInput): AddPipelineOutputResult!
  deletePipelineVersion(input: DeletePipelineVersionInput!): DeletePipelineVersionResult!
  createWorkspace(input: CreateWorkspaceInput!): CreateWorkspaceResult!
  updateWorkspace(input: UpdateWorkspaceInput!): UpdateWorkspaceResult!
  deleteWorkspace(input: DeleteWorkspaceInput!): DeleteWorkspaceResult!
  archiveWorkspace(input: ArchiveWorkspaceInput!): ArchiveWorkspaceResult!
  inviteWorkspaceMember(input: InviteWorkspaceMemberInput!): InviteWorkspaceMemberResult!
  updateWorkspaceMember(input: UpdateWorkspaceMemberInput!): UpdateWorkspaceMemberResult!
  deleteWorkspaceMember(input: DeleteWorkspaceMemberInput!): DeleteWorkspaceMemberResult!
  generateWorkspaceToken(input: GenerateWorkspaceTokenInput!): GenerateWorkspaceTokenResult!
  joinWorkspace(input: JoinWorkspaceInput!): JoinWorkspaceResult!
  declineWorkspaceInvitation(input: DeclineWorkspaceInvitationInput!): DeclineWorkspaceInvitationResult!
  resendWorkspaceInvitation(input: ResendWorkspaceInvitationInput!): ResendWorkspaceInvitationResult!
  deleteWorkspaceInvitation(input: DeleteWorkspaceInvitationInput!): DeleteWorkspaceInvitationResult!
  createConnection(input: CreateConnectionInput!): CreateConnectionResult!
  updateConnection(input: UpdateConnectionInput!): UpdateConnectionResult!
  deleteConnection(input: DeleteConnectionInput!): DeleteConnectionResult!
  generateNewDatabasePassword(input: GenerateNewDatabasePasswordInput!): GenerateNewDatabasePasswordResult!
  deleteBucketObject(input: DeleteBucketObjectInput!): DeleteBucketObjectResult!
  prepareObjectDownload(input: PrepareObjectDownloadInput!): PrepareObjectDownloadResult!
  prepareObjectUpload(input: PrepareObjectUploadInput!): PrepareObjectUploadResult!
  createBucketFolder(input: CreateBucketFolderInput!): CreateBucketFolderResult!
  createDataset(input: CreateDatasetInput!): CreateDatasetResult!
  updateDataset(input: UpdateDatasetInput!): UpdateDatasetResult!
  deleteDataset(input: DeleteDatasetInput!): DeleteDatasetResult!
  createDatasetVersion(input: CreateDatasetVersionInput!): CreateDatasetVersionResult!
  deleteDatasetVersion(input: DeleteDatasetVersionInput!): DeleteDatasetVersionResult!
  createDatasetVersionFile(input: CreateDatasetVersionFileInput!): CreateDatasetVersionFileResult!
  prepareVersionFileDownload(input: PrepareVersionFileDownloadInput!): PrepareVersionFileDownloadResult!
  linkDataset(input: LinkDatasetInput!): LinkDatasetResult!
  deleteDatasetLink(input: DeleteDatasetLinkInput!): DeleteDatasetLinkResult!
  pinDataset(input: PinDatasetInput!): PinDatasetResult!
}

type NotebookServer {
  name: String!
  url: String!
  ready: Boolean!
}

enum OrderByDirection {
  ASC
  DESC
}

type Organization {
  id: UUID!
  name: String!
  type: String!
  url: String!
  contactInfo: String!
}

input OrganizationInput {
  id: UUID!
  name: String
  type: String
  url: String
  contactInfo: String
}

input ParameterInput {
  code: String!
  type: String!
  name: String
  multiple: Boolean
  required: Boolean
  default: Generic
  help: String
  choices: [Generic!]
}

enum PermissionMode {
  OWNER
  EDITOR
  VIEWER
}

enum PinDatasetError {
  LINK_NOT_FOUND
  WORKSPACE_NOT_FOUND
  PERMISSION_DENIED
}

input PinDatasetInput {
  linkId: ID!
  pinned: Boolean!
}

type PinDatasetResult {
  link: DatasetLink
  success: Boolean!
  errors: [PinDatasetError!]!
}

type Pipeline {
  id: UUID!
  name: String
  code: String!
  permissions: PipelinePermissions!
  workspace: Workspace
  config: JSON!
  schedule: String
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
  currentVersion: PipelineVersion
  runs(page: Int, perPage: Int, orderBy: PipelineRunOrderBy): PipelineRunPage!
  versions(page: Int, perPage: Int): PipelineVersionPage!
  recipients: [PipelineRecipient!]!
  webhookEnabled: Boolean!
  webhookUrl: String
}

enum PipelineError {
  PIPELINE_NOT_FOUND
  PIPELINE_VERSION_NOT_FOUND
  PIPELINE_DOES_NOT_SUPPORT_PARAMETERS
  WORKSPACE_NOT_FOUND
  PIPELINE_ALREADY_EXISTS
  INVALID_CONFIG
  PIPELINE_ALREADY_COMPLETED
  INVALID_TIMEOUT_VALUE
  PERMISSION_DENIED
  FILE_NOT_FOUND
  TABLE_NOT_FOUND
}

type PipelineParameter {
  code: String!
  name: String!
  type: String!
  multiple: Boolean!
  required: Boolean!
  default: Generic
  help: String
  choices: [Generic!]
}

type PipelinePermissions {
  update: Boolean!
  delete: Boolean!
  run: Boolean!
  deleteVersion: Boolean!
  schedule: Boolean!
}

type PipelineRecipient {
  user: User!
  pipeline: Pipeline!
}

type PipelineRun {
  id: UUID!
  run_id: UUID!
  user: User
  pipeline: Pipeline!
  version: PipelineVersion!
  config: JSON!
  status: PipelineRunStatus!
  executionDate: DateTime
  duration: Int
  progress: Int!
  triggerMode: PipelineRunTrigger
  messages: [PipelineRunMessage!]!
  logs: String
  outputs: [PipelineRunOutput!]!
  code: String!
  sendMailNotifications: Boolean!
  timeout: Int
  datasetVersions: [DatasetVersion!]!
}

type PipelineRunMessage {
  message: String!
  priority: MessagePriority!
  timestamp: DateTime
}

enum PipelineRunOrderBy {
  EXECUTION_DATE_DESC
  EXECUTION_DATE_ASC
}

union PipelineRunOutput = BucketObject | GenericOutput | DatabaseTable

type PipelineRunPage {
  items: [PipelineRun!]!
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
}

enum PipelineRunStatus {
  success
  running
  failed
  queued
}

enum PipelineRunTrigger {
  scheduled
  manual
  webhook
}

type PipelinesPage {
  items: [Pipeline!]!
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
}

input PipelineTokenInput {
  workspaceSlug: String!
  pipelineCode: String!
}

type PipelineTokenResult {
  success: Boolean!
  errors: [PipelineError!]!
  token: String
}

type PipelineVersion {
  id: UUID!
  user: User
  pipeline: Pipeline!
  number: Int!
  createdAt: DateTime!
  parameters: [PipelineParameter!]!
  zipfile: String!
  timeout: Int
}

type PipelineVersionPage {
  items: [PipelineVersion!]!
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
}

input PrepareAccessmodFileDownloadInput {
  fileId: String!
}

type PrepareAccessmodFileDownloadResult {
  success: Boolean!
  downloadUrl: String
}

input PrepareAccessmodFilesetVisualizationDownloadInput {
  id: String!
}

type PrepareAccessmodFilesetVisualizationDownloadResult {
  success: Boolean!
  url: String
}

input PrepareAccessmodFileUploadInput {
  filesetId: String!
  mimeType: String!
}

type PrepareAccessmodFileUploadResult {
  success: Boolean!
  uploadUrl: String
  fileUri: String
}

input PrepareDownloadURLInput {
  uri: URL!
}

type PrepareDownloadURLResult {
  success: Boolean!
  url: URL
}

enum PrepareObjectDownloadError {
  NOT_FOUND
  PERMISSION_DENIED
}

input PrepareObjectDownloadInput {
  workspaceSlug: String!
  objectKey: String!
}

type PrepareObjectDownloadResult {
  success: Boolean!
  downloadUrl: URL
  errors: [PrepareObjectDownloadError!]!
}

enum PrepareObjectUploadError {
  PERMISSION_DENIED
}

input PrepareObjectUploadInput {
  workspaceSlug: String!
  objectKey: String!
  contentType: String
}

type PrepareObjectUploadResult {
  uploadUrl: URL
  success: Boolean!
  errors: [PrepareObjectUploadError!]!
}

enum PrepareVersionFileDownloadError {
  FILE_NOT_FOUND
  FILE_NOT_UPLOADED
  PERMISSION_DENIED
}

input PrepareVersionFileDownloadInput {
  fileId: ID!
}

type PrepareVersionFileDownloadResult {
  downloadUrl: String
  success: Boolean!
  errors: [PrepareVersionFileDownloadError!]!
}

type Query {
  search(query: String, page: Int, perPage: Int, datasourceIds: [UUID!], types: [String!]): SearchQueryResult!
  catalog(path: String, page: Int, perPage: Int): CatalogPage!
  me: Me!
  team(id: UUID!): Team
  teams(term: String, page: Int, perPage: Int): TeamPage!
  organizations: [Organization!]!
  dags(page: Int, perPage: Int): DAGPage!
  dag(id: UUID!): DAG
  dagRun(id: UUID!): DAGRun
  accessmodProject(id: String): AccessmodProject
  accessmodProjects(term: String, countries: [String!], teams: [String!], page: Int, perPage: Int, orderBy: AccessmodProjectOrder): AccessmodProjectPage!
  accessmodFileset(id: String): AccessmodFileset
  accessmodFilesets(projectId: String!, roleId: String, term: String, mode: AccessmodFilesetMode, page: Int, perPage: Int): AccessmodFilesetPage!
  accessmodFilesetRole(id: String!): AccessmodFilesetRole
  accessmodFilesetRoles: [AccessmodFilesetRole!]!
  accessmodAnalysis(id: String): AccessmodAnalysis
  accessmodAnalyses(projectId: String!, page: Int, perPage: Int): AccessmodAnalysisPage!
  accessmodAccessRequests(page: Int, perPage: Int): AccessmodAccessRequestPage!
  country(code: String, alpha3: String): Country
  boundaries(country_code: String!, level: String!): [WHOBoundary!]!
  countries: [Country!]!
  notebooksUrl: URL!
  totalNotebooks: Int!
  lastActivities: [Activity!]!
  pipelines(workspaceSlug: String, page: Int, perPage: Int): PipelinesPage!
  pipeline(id: UUID!): Pipeline
  pipelineByCode(workspaceSlug: String!, code: String!): Pipeline
  pipelineRun(id: UUID!): PipelineRun
  workspace(slug: String!): Workspace
  workspaces(query: String, page: Int, perPage: Int): WorkspacePage!
  pendingWorkspaceInvitations(page: Int! = 1, perPage: Int = 10): WorkspaceInvitationPage!
  databaseTable(id: String!): DatabaseTable
  connection(id: UUID!): Connection
  dataset(id: ID!): Dataset
  datasetVersion(id: ID!): DatasetVersion
  datasetLink(id: ID!): DatasetLink
  datasetLinkBySlug(workspaceSlug: String!, datasetSlug: String!): DatasetLink
  datasets(query: String, page: Int = 1, perPage: Int = 15): DatasetPage!
}

enum RegisterError {
  ALREADY_LOGGED_IN
  EMAIL_TAKEN
  INVALID_TOKEN
  PASSWORD_MISMATCH
  INVALID_PASSWORD
}

input RegisterInput {
  password1: String!
  password2: String!
  firstName: String!
  lastName: String!
  invitationToken: String!
}

type RegisterResult {
  success: Boolean!
  errors: [RegisterError!]
}

enum RequestAccessmodAccessError {
  ALREADY_EXISTS
  MUST_ACCEPT_TOS
  INVALID
}

input RequestAccessmodAccessInput {
  firstName: String!
  lastName: String!
  email: String!
  acceptTos: Boolean!
}

type RequestAccessmodAccessInputResult {
  success: Boolean!
  errors: [RequestAccessmodAccessError!]!
}

enum ResendWorkspaceInvitationError {
  INVITATION_NOT_FOUND
  PERMISSION_DENIED
}

input ResendWorkspaceInvitationInput {
  invitationId: UUID!
}

type ResendWorkspaceInvitationResult {
  success: Boolean!
  errors: [ResendWorkspaceInvitationError!]!
}

input ResetPasswordInput {
  email: String!
}

type ResetPasswordResult {
  success: Boolean!
}

enum RunDAGError {
  DAG_NOT_FOUND
  INVALID_CONFIG
}

input RunDAGInput {
  dagId: UUID!
  config: JSON!
}

type RunDAGResult {
  success: Boolean!
  errors: [RunDAGError!]!
  dagRun: DAGRun
  dag: DAG
}

input RunPipelineInput {
  id: UUID!
  version: Int
  config: JSON!
  sendMailNotifications: Boolean
}

type RunPipelineResult {
  success: Boolean!
  errors: [PipelineError!]!
  run: PipelineRun
}

type S3Bucket {
  id: String!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type S3Object {
  id: String!
  bucket: S3Bucket!
  filename: String!
  key: String!
  parentKey: String!
  size: Int!
  storageClass: String!
  type: String!
  lastModified: DateTime!
  etag: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type S3ObjectPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [S3Object!]!
}

type SearchQueryResult {
  results: [SearchResult!]!
  types: [SearchType!]!
}

type SearchResult {
  object: SearchResultObject!
  rank: Float!
}

union SearchResultObject = CatalogEntry

type SearchType {
  value: String!
  label: String!
}

enum SetDAGRunFavoriteError {
  NOT_FOUND
  INVALID
  MISSING_LABEL
}

input SetDAGRunFavoriteInput {
  id: UUID!
  label: String
  isFavorite: Boolean!
}

type SetDAGRunFavoriteResult {
  success: Boolean!
  errors: [SetDAGRunFavoriteError!]!
  dagRun: DAGRun
}

enum SetPasswordError {
  USER_NOT_FOUND
  PASSWORD_MISMATCH
  INVALID_TOKEN
  INVALID_PASSWORD
}

input SetPasswordInput {
  uidb64: String!
  token: String!
  password1: String!
  password2: String!
}

type SetPasswordResult {
  success: Boolean!
  error: SetPasswordError
}

scalar SimplifiedExtentType

scalar StackPriorities

type TableColumn {
  name: String!
  type: String!
}

type TableRowsPage {
  pageNumber: Int!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  items: [JSON!]!
}

type Tag {
  id: String!
  name: String!
}

type Team {
  id: UUID!
  name: String!
  memberships(page: Int, perPage: Int): MembershipPage!
  permissions: TeamPermissions!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [Team!]!
}

type TeamPermissions {
  update: Boolean!
  createMembership: Boolean!
  delete: Boolean!
}

scalar TimeThresholds

enum UpdateAccessmodAccessibilityAnalysisError {
  NOT_FOUND
  NAME_DUPLICATE
}

input UpdateAccessmodAccessibilityAnalysisInput {
  id: String!
  name: String
  landCoverId: String
  demId: String
  stackId: String
  stackPriorities: StackPriorities
  transportNetworkId: String
  waterId: String
  barrierId: String
  movingSpeeds: MovingSpeeds
  healthFacilitiesId: String
  invertDirection: Boolean
  maxTravelTime: Int
  waterAllTouched: Boolean
  algorithm: AccessmodAccessibilityAnalysisAlgorithm
  knightMove: Boolean
}

type UpdateAccessmodAccessibilityAnalysisResult {
  success: Boolean!
  analysis: AccessmodAccessibilityAnalysis
  errors: [UpdateAccessmodAccessibilityAnalysisError!]!
}

enum UpdateAccessmodFilesetError {
  NOT_FOUND
  NAME_DUPLICATE
  PERMISSION_DENIED
}

input UpdateAccessmodFilesetInput {
  id: String!
  name: String
  metadata: AccessmodFilesetMetadata
}

type UpdateAccessmodFilesetResult {
  success: Boolean!
  fileset: AccessmodFileset
  errors: [UpdateAccessmodFilesetError!]!
}

enum UpdateAccessmodProjectError {
  NOT_FOUND
  NAME_DUPLICATE
  PERMISSION_DENIED
}

input UpdateAccessmodProjectInput {
  id: String!
  name: String
  description: String
}

enum UpdateAccessmodProjectMemberError {
  PERMISSION_DENIED
  NOT_FOUND
  NOT_IMPLEMENTED
}

input UpdateAccessmodProjectMemberInput {
  id: String!
  mode: PermissionMode!
}

type UpdateAccessmodProjectMemberResult {
  success: Boolean!
  member: AccessmodProjectMember
  errors: [UpdateAccessmodProjectMemberError!]!
}

type UpdateAccessmodProjectResult {
  success: Boolean!
  project: AccessmodProject
  errors: [UpdateAccessmodProjectError!]!
}

enum UpdateAccessmodZonalStatisticsError {
  NOT_FOUND
  NAME_DUPLICATE
}

input UpdateAccessmodZonalStatisticsInput {
  id: String!
  name: String
  populationId: String
  travelTimesId: String
  boundariesId: String
  timeThresholds: TimeThresholds
}

type UpdateAccessmodZonalStatisticsResult {
  success: Boolean!
  analysis: AccessmodZonalStatistics
  errors: [UpdateAccessmodZonalStatisticsError!]!
}

enum UpdateConnectionError {
  NOT_FOUND
  PERMISSION_DENIED
  INVALID_SLUG
}

input UpdateConnectionInput {
  id: String!
  name: String
  slug: String
  description: String
  fields: [ConnectionFieldInput!]
}

type UpdateConnectionResult {
  success: Boolean!
  connection: Connection
  errors: [UpdateConnectionError!]!
}

enum UpdateDAGError {
  NOT_FOUND
  INVALID
}

input UpdateDAGInput {
  id: UUID!
  label: String
  description: String
  schedule: String
  countries: [CountryInput!]
}

type UpdateDAGResult {
  success: Boolean!
  errors: [UpdateDAGError!]!
  dag: DAG
}

enum UpdateDatasetError {
  DATASET_NOT_FOUND
  PERMISSION_DENIED
}

input UpdateDatasetInput {
  datasetId: ID!
  name: String
  description: String
}

type UpdateDatasetResult {
  dataset: Dataset
  success: Boolean!
  errors: [UpdateDatasetError!]!
}

enum UpdateMembershipError {
  PERMISSION_DENIED
  NOT_FOUND
  INVALID_ROLE
}

input UpdateMembershipInput {
  id: UUID!
  role: MembershipRole!
}

type UpdateMembershipResult {
  success: Boolean!
  membership: Membership
  errors: [UpdateMembershipError!]!
}

enum UpdatePipelineError {
  NOT_FOUND
  PERMISSION_DENIED
  INVALID_CONFIG
}

input UpdatePipelineInput {
  id: UUID!
  name: String
  config: JSON
  schedule: String
  description: String
  recipientIds: [UUID!]
  webhookEnabled: Boolean
}

input UpdatePipelineProgressInput {
  percent: Int!
}

type UpdatePipelineProgressResult {
  success: Boolean!
  errors: [PipelineError!]!
}

type UpdatePipelineResult {
  success: Boolean!
  errors: [UpdatePipelineError!]!
  pipeline: Pipeline
}

enum UpdateTeamError {
  NOT_FOUND
  PERMISSION_DENIED
  NAME_DUPLICATE
}

input UpdateTeamInput {
  id: UUID!
  name: String
}

type UpdateTeamResult {
  team: Team
  success: Boolean!
  errors: [UpdateTeamError!]!
}

enum UpdateUserError {
  PERMISSION_DENIED
  INVALID_LANGUAGE
}

input UpdateUserInput {
  firstName: String
  lastName: String
  language: String
}

type UpdateUserResult {
  success: Boolean!
  user: User
  errors: [UpdateUserError!]!
}

enum UpdateWorkspaceError {
  PERMISSION_DENIED
  NOT_FOUND
}

input UpdateWorkspaceInput {
  slug: String!
  name: String
  description: String
  countries: [CountryInput!]
}

enum UpdateWorkspaceMemberError {
  MEMBERSHIP_NOT_FOUND
  PERMISSION_DENIED
}

input UpdateWorkspaceMemberInput {
  membershipId: UUID!
  role: WorkspaceMembershipRole!
}

type UpdateWorkspaceMemberResult {
  success: Boolean!
  errors: [UpdateWorkspaceMemberError!]!
  workspaceMembership: WorkspaceMembership
}

type UpdateWorkspaceResult {
  success: Boolean!
  errors: [UpdateWorkspaceError!]!
  workspace: Workspace
}

input UploadPipelineInput {
  workspaceSlug: String!
  code: String!
  parameters: [ParameterInput!]!
  zipfile: String!
  timeout: Int
}

type UploadPipelineResult {
  success: Boolean!
  version: Int
  errors: [PipelineError!]!
}

scalar URL

type User {
  id: UUID!
  email: String!
  firstName: String
  lastName: String
  displayName: String!
  language: String!
  avatar: Avatar!
  dateJoined: DateTime!
  lastLogin: DateTime
}

scalar UUID

enum VerifyDeviceError {
  NO_DEVICE
  INVALID_OTP
}

input VerifyDeviceInput {
  token: String
}

type VerifyDeviceResult {
  success: Boolean!
  errors: [VerifyDeviceError!]
}

type WHOBoundary {
  id: String!
  name: String!
  country: Country!
  administrative_level: Int!
  parent: String
  extent: String!
}

type WHOInfo {
  region: WHORegion
  defaultCRS: Int!
  simplifiedExtent: SimplifiedExtentType
}

type WHORegion {
  code: String!
  name: String!
}

type Workspace {
  slug: String!
  name: String!
  description: String
  members(page: Int, perPage: Int): WorkspaceMembershipPage!
  permissions: WorkspacePermissions!
  countries: [Country!]!
  createdAt: DateTime!
  updatedAt: DateTime
  createdBy: User!
  connections: [Connection!]!
  invitations(includeAccepted: Boolean, page: Int, perPage: Int): WorkspaceInvitationPage!
  database: Database!
  bucket: Bucket!
  datasets(pinned: Boolean, query: String, page: Int = 1, perPage: Int = 15): DatasetLinkPage!
}

type WorkspaceInvitation {
  id: UUID!
  email: String!
  workspace: Workspace!
  role: WorkspaceMembershipRole!
  status: WorkspaceInvitationStatus!
  invitedBy: User
  createdAt: DateTime!
  updatedAt: DateTime
}

type WorkspaceInvitationPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [WorkspaceInvitation!]!
}

enum WorkspaceInvitationStatus {
  PENDING
  DECLINED
  ACCEPTED
}

type WorkspaceMembership {
  id: UUID!
  user: User!
  workspace: Workspace!
  role: WorkspaceMembershipRole!
  createdAt: DateTime!
  updatedAt: DateTime
}

type WorkspaceMembershipPage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [WorkspaceMembership!]!
}

enum WorkspaceMembershipRole {
  ADMIN
  EDITOR
  VIEWER
}

type WorkspacePage {
  pageNumber: Int!
  totalPages: Int!
  totalItems: Int!
  items: [Workspace!]!
}

type WorkspacePermissions {
  update: Boolean!
  delete: Boolean!
  manageMembers: Boolean!
  createConnection: Boolean!
  launchNotebookServer: Boolean!
  createPipeline: Boolean!
  createObject: Boolean!
  deleteObject: Boolean!
  downloadObject: Boolean!
  createDataset: Boolean!
}

