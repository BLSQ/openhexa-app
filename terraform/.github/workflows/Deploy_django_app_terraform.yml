name: Deploy django app on GKE using terraform 
on:
  #  push:
  #    branches:
  workflow_dispatch:
    inputs:
      namespace:
        description: Namespace
        required: true
    output_file_path:
        description: Get outputs from file
        required: true
  

jobs:
  deploy:
    name: Provisioning using terraform
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.TERRAFORM_AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.TERRAFORM_AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.TERRAFORM_AWS_REGION }}
      GOOGLE_CREDENTIALS: ${{ secrets.TERRAFORM_GOOGLE_CREDENTIALS_TEST }}

    steps:
      # Checkout code
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0  # fetch all history for all branches and tags

      # Python setup
      - name: setup python
        uses: actions/setup-python@v2
        with:
          python-version: 3.9

      - name: Install dependencies and PyYaml
        run: |
          python -m pip install --upgrade pip
          pip install PyYaml

      # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@3d8debd658c92063839bc97da5c2427100420dec

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        run: terraform init

      # Generates an execution plan for Terraform
      - name: Terraform Plan
        run: terraform plan 

      # Apply the changes required to reach the desired state of the configuration, or the pre-determined set of actions generated by terraform plan 
      - name: Terraform apply
        run: terraform apply

      # Gcloud stuff (see https://github.com/google-github-actions/setup-gcloud/tree/master/example-workflows/gke)
      - name: Setup gcloud
        uses: GoogleCloudPlatform/github-actions/setup-gcloud@94337306dda8180d967a56932ceb4ddcf01
        with:
           project_id: ${{ secrets.GCP_PROJECT_ID_TEST }}
           service_account_key: ${{ secrets.GKE_SA_KEY_TEST }}
           export_default_credentials: true
           
           
      # Get outputs from file
      - name: Terraform Output
        run: terraform output >> "$output_file_path"
        
      # Export variables from output file
      - name: Export Variables
        run: |
          sed -i 's/ //g' ${{ github.event.inputs.output_file_path }} && sed -i 's/"//g' ${{ github.event.inputs.output_file_path }}
          . $output_file_path

      # Get the connection string of your Cloud SQL instance and add it into $output_file_path
      - name: Export Variables
        run: |
         gcloud sql instances describe $gcp_sql_database_name  >> instance_description.yaml
         ConnectionName=$(yq -r .connectionName test.yaml)
         rm instance_description.yaml
         echo CLOUDSQL_CONNECTION_STRING=$ConnectionName >> ${{ github.event.inputs.output_file_path }}  

      # Make sure that the kubectl utility can access the newly created cluster
      - name: Access to cluster
        run: |
         gcloud container clusters get-credentials $gcp_gke_cluster_name --zone $gcp_gke_cluster_zone
 
      # Create a specific Kubernetes namespace
      - name: Create a Kubernetes namespace
        run: |
         kubectl create namespace ${{ github.event.inputs.namesapce }} 

      # Create a secret for the Cloud SQL proxy
      - name : Create a secret
        run: |
         kubectl create secret generic cloudsql-oauth-credentials -n  ${{ github.event.inputs.namesapce }} 
         
      # Generate a secret key for the Django app
      - name: Generate a secret key
        run: |
         SECRET_KEY=$(docker-compose run app manage generate_secret_key)

      # Create a secret for the Django environment variables
      - name: Create a secret for the Django environment variables
        run: |
         kubectl create secret generic app-secret -n  ${{ github.event.inputs.namesapce }}  \
         --from-literal DATABASE_USER=$gcp_sql_database_password\
         --from-literal DATABASE_PASSWORD=$gcp_sql_database_password \
         --from-literal DATABASE_NAME=$gcp_sql_database_password \
         --from-literal DATABASE_PORT=5432 \
         --from-literal SECRET_KEY=$SECRET_KEY

      # Copy the sample file
      - name: Copy the sample file
        run: |
         cp k8s/app.yaml.dist k8s/app.yaml

      # Transform output file to YAML
      - name: Transform output file to YAML
        run: |
         sed -i 's/=/: /g' ${{ github.event.inputs.output_file_path }} 

      # Update app file using Python
      - name: Update app file
        run: |
         python bin/update_app_file.py  \
         ${{ github.event.inputs.output_file_path }} \
         k8s/app.yaml 
         
       # Delete output file
      - name: Delete output file
        run: |
          rm ${{ github.event.inputs.output_file_path }} 

      # Deploy the app component 
      - name: Deploy app
        run: |
          kubectl apply -n ${{ github.event.inputs.namespace }}  -f k8s/app.yaml


      # Migrate
      - name: Migration
        run: |
          kubectl exec deploy/app-deployment -n  ${{ github.event.inputs.namesapce }}  -- python manage.py migrate
          
      # Load fixtures
      - name: Load fixtures
        run: |
          kubectl exec deploy/app-deployment -n  ${{ github.event.inputs.namesapce }}  -- python manage.py loaddata demo.json

      # Need to run a command in a pod
      - name: Run command in pod
        run: |
          kubectl exec -it deploy/app-deployment -n  ${{ github.event.inputs.namesapce }}  -- bash

      # Get the public IP of the load balancer
      - name: Get public IP of load balancer
        run: |
          kubectl get service app-service -n  ${{ github.event.inputs.namesapce }} 
