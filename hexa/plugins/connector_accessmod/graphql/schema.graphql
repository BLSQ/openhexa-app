union AccessmodOwner = User | Team

interface AccessmodOwnership {
    owner: AccessmodOwner
}

# Projects
type AccessmodProject implements AccessmodOwnership {
    id: String!
    name: String!
    spatialResolution: Int!
    description: String!
    crs: Int!
    country: Country!
    author: User!
    owner: AccessmodOwner
    extent: String
    dem: AccessmodFileset
    authorizedActions: [AccessmodProjectAuthorizedActions!]!
    permissions: [AccessmodProjectPermission!]!
    createdAt: DateTime!
    updatedAt: DateTime!
}

enum AccessmodProjectAuthorizedActions {
    UPDATE
    DELETE
    CREATE_FILESET
    CREATE_ANALYSIS
    CREATE_PERMISSION
}
type AccessmodProjectPage {
    pageNumber: Int!
    totalPages: Int!
    totalItems: Int!
    items: [AccessmodProject!]!
}
input CreateAccessmodProjectInput {
    name: String!
    spatialResolution: Int!
    description: String
    crs: Int!
    extent: String
    country: CountryInput!
}
type CreateAccessmodProjectResult {
    success: Boolean!
    project: AccessmodProject
    errors: [CreateAccessmodProjectError!]!
}
enum CreateAccessmodProjectError {
    NAME_DUPLICATE
    PERMISSION_DENIED
}
input UpdateAccessmodProjectInput {
    id: String!
    name: String
    description: String
    extent: String
    demId: String
}
type UpdateAccessmodProjectResult {
    success: Boolean!
    project: AccessmodProject
    errors: [UpdateAccessmodProjectError!]!
}
enum UpdateAccessmodProjectError {
    NOT_FOUND
    NAME_DUPLICATE
    PERMISSION_DENIED
}
input DeleteAccessmodProjectInput {
    id: String!
}
type DeleteAccessmodProjectResult {
    success: Boolean!
    errors: [DeleteAccessmodProjectError!]!
}
enum DeleteAccessmodProjectError {
    NOT_FOUND
    PERMISSION_DENIED
}
type AccessmodProjectPermissionPage {
    pageNumber: Int!
    totalPages: Int!
    totalItems: Int!
    items: [AccessmodProjectPermission!]!
}
type AccessmodProjectPermission {
    id: String!
    user: User
    team: Team
    project: AccessmodProject!
    mode: PermissionMode!
    authorizedActions: [AccessmodProjectPermissionAuthorizedActions!]!
    createdAt: DateTime!
    updatedAt: DateTime!
}
enum AccessmodProjectPermissionAuthorizedActions {
    UPDATE
    DELETE
}
input CreateAccessmodProjectPermissionInput {
    userId: String
    teamId: String
    projectId: String!
    mode: PermissionMode!
}
type CreateAccessmodProjectPermissionResult {
    success: Boolean!
    permission: AccessmodProjectPermission
    errors: [CreateAccessmodProjectPermissionError!]!
}
enum CreateAccessmodProjectPermissionError {
    PERMISSION_DENIED
    NOT_FOUND
}
input UpdateAccessmodProjectPermissionInput {
    id: String!
    mode: PermissionMode!
}
type UpdateAccessmodProjectPermissionResult {
    success: Boolean!
    permission: AccessmodProjectPermission
    errors: [UpdateAccessmodProjectPermissionError!]!
}
enum UpdateAccessmodProjectPermissionError {
    PERMISSION_DENIED
    NOT_FOUND
}
input DeleteAccessmodProjectPermissionInput {
    id: String!
}
type DeleteAccessmodProjectPermissionResult {
    success: Boolean!
    errors: [DeleteAccessmodProjectPermissionError!]!
}
enum DeleteAccessmodProjectPermissionError {
    PERMISSION_DENIED
    NOT_FOUND
}

enum AccessmodProjectOrder {
    UPDATED_AT_DESC
    UPDATED_AT_ASC
    NAME_DESC
    NAME_ASC
}

extend type Query {
    accessmodProject(id: String): AccessmodProject
    accessmodProjects(term: String, countries: [String!], teams: [String!], page: Int, perPage: Int, orderBy: AccessmodProjectOrder): AccessmodProjectPage!
}
extend type Mutation {
    createAccessmodProject(input: CreateAccessmodProjectInput): CreateAccessmodProjectResult!
    updateAccessmodProject(input: UpdateAccessmodProjectInput): UpdateAccessmodProjectResult!
    deleteAccessmodProject(input: DeleteAccessmodProjectInput): DeleteAccessmodProjectResult!
    createAccessmodProjectPermission(input: CreateAccessmodProjectPermissionInput!): CreateAccessmodProjectPermissionResult!
    updateAccessmodProjectPermission(input: UpdateAccessmodProjectPermissionInput!): UpdateAccessmodProjectPermissionResult!
    deleteAccessmodProjectPermission(input: DeleteAccessmodProjectPermissionInput!): DeleteAccessmodProjectPermissionResult!
}

# Filesets
type AccessmodFileset implements AccessmodOwnership {
    id: String!
    name: String!
    status: AccessmodFilesetStatus!
    role: AccessmodFilesetRole!
    author: User!
    owner: AccessmodOwner
    files: [AccessmodFile!]!
    metadata: AccessmodFilesetMetadata!
    authorizedActions: [AccessmodFilesetAuthorizedActions!]!
    createdAt: DateTime!
    updatedAt: DateTime!
}
enum AccessmodFilesetStatus {
    PENDING
    VALIDATING
    VALID
    INVALID
    TO_ACQUIRE
}
scalar AccessmodFilesetMetadata
enum AccessmodFilesetAuthorizedActions {
    UPDATE
    DELETE
    CREATE_FILE
}
type AccessmodFilesetPage {
    pageNumber: Int!
    totalPages: Int!
    totalItems: Int!
    items: [AccessmodFileset!]!
}
type AccessmodFilesetRole {
    id: String!
    code: AccessmodFilesetRoleCode!
    name: String!
    format: AccessmodFilesetFormat!
    createdAt: DateTime!
    updatedAt: DateTime!
}
enum AccessmodFilesetRoleCode {
    BARRIER
    CATCHMENT_AREAS
    COVERAGE
    DEM
    FRICTION_SURFACE
    GEOMETRY
    HEALTH_FACILITIES
    LAND_COVER
    MOVING_SPEEDS
    POPULATION
    TRANSPORT_NETWORK
    TRAVEL_TIMES
    WATER
    STACK
}
enum AccessmodFilesetFormat {
    VECTOR
    RASTER
    TABULAR
}
type AccessmodFile {
    id: String!
    uri: String!
    name: String!
    fileset: AccessmodFileset
    mimeType: String!
    createdAt: DateTime!
    updatedAt: DateTime!
}
input CreateAccessmodFilesetInput {
    name: String!
    projectId: String!
    roleId: String!
    automatic: Boolean
}
type CreateAccessmodFilesetResult {
    success: Boolean!
    fileset: AccessmodFileset
    errors: [CreateAccessmodFilesetError!]!
}
enum CreateAccessmodFilesetError {
    NAME_DUPLICATE
    PERMISSION_DENIED
}
input PrepareAccessmodFileUploadInput {
    filesetId: String!
    mimeType: String!
}
type PrepareAccessmodFileUploadResult {
    success: Boolean!
    uploadUrl: String
    fileUri: String
}
input CreateAccessmodFileInput {
    filesetId: String!
    uri: String!
    mimeType: String!
}
type CreateAccessmodFileResult {
    success: Boolean!
    file: AccessmodFile
    errors: [CreateAccessmodFileError!]!
}
enum CreateAccessmodFileError {
    URI_DUPLICATE
}
input PrepareAccessmodFileDownloadInput {
    fileId: String!
}
type PrepareAccessmodFileDownloadResult {
    success: Boolean!
    downloadUrl: String
}
input DeleteAccessmodFilesetInput {
    id: String!
}
type DeleteAccessmodFilesetResult {
    success: Boolean!
    errors: [DeleteAccessmodFilesetError!]!
}
enum DeleteAccessmodFilesetError {
    NOT_FOUND
}
input DeleteAccessmodFileInput {
    id: String!
}
type DeleteAccessmodFileResult {
    success: Boolean!
    errors: [DeleteAccessmodFileError!]!
}
enum DeleteAccessmodFileError {
    NOT_FOUND
}
extend type Query {
    accessmodFileset(id: String): AccessmodFileset
    accessmodFilesets(projectId: String!, roleId: String, term: String, page: Int, perPage: Int): AccessmodFilesetPage!
    accessmodFilesetRole(id: String!): AccessmodFilesetRole
    accessmodFilesetRoles: [AccessmodFilesetRole!]!
}
extend type Mutation {
    createAccessmodFileset(input: CreateAccessmodFilesetInput): CreateAccessmodFilesetResult!
    deleteAccessmodFileset(input: DeleteAccessmodFilesetInput): DeleteAccessmodFilesetResult!
    prepareAccessmodFileUpload(input: PrepareAccessmodFileUploadInput): PrepareAccessmodFileUploadResult!
    prepareAccessmodFileDownload(input: PrepareAccessmodFileDownloadInput): PrepareAccessmodFileDownloadResult!
    createAccessmodFile(input: CreateAccessmodFileInput): CreateAccessmodFileResult!
    deleteAccessmodFile(input: DeleteAccessmodFileInput): DeleteAccessmodFileResult!
}

# Analysis
enum AccessmodAnalysisType {
    ACCESSIBILITY
    GEOGRAPHIC_COVERAGE
}
enum AccessmodAnalysisStatus {
    DRAFT
    READY
    QUEUED
    RUNNING
    SUCCESS
    FAILED
}

interface AccessmodAnalysis {
    id: String!
    type: AccessmodAnalysisType!
    status: AccessmodAnalysisStatus!
    name: String!
    author: User!
    authorizedActions: [AccessmodAnalysisAuthorizedActions!]!
    createdAt: DateTime!
    updatedAt: DateTime!
}
enum AccessmodAnalysisAuthorizedActions {
    UPDATE
    DELETE
    RUN
}
enum AccessmodAccessibilityAnalysisAlgorithm {
    ANISOTROPIC
    ISOTROPIC
}

scalar StackPriorities
scalar MovingSpeeds
type AccessmodAccessibilityAnalysis implements AccessmodAnalysis & AccessmodOwnership {
    id: String!
    type: AccessmodAnalysisType!
    status: AccessmodAnalysisStatus!
    name: String!
    owner: AccessmodOwner
    author: User!
    authorizedActions: [AccessmodAnalysisAuthorizedActions!]!
    createdAt: DateTime!
    updatedAt: DateTime!
    landCover: AccessmodFileset
    dem: AccessmodFileset
    transportNetwork: AccessmodFileset
    water: AccessmodFileset
    barrier: AccessmodFileset
    stack: AccessmodFileset
    stackPriorities: StackPriorities
    movingSpeeds: MovingSpeeds
    healthFacilities: AccessmodFileset
    invertDirection: Boolean
    maxTravelTime: Int
    waterAllTouched: Boolean
    algorithm: AccessmodAccessibilityAnalysisAlgorithm
    knightMove: Boolean
    travelTimes: AccessmodFileset
    frictionSurface: AccessmodFileset
}
type AccessmodGeographicCoverageAnalysis implements AccessmodAnalysis & AccessmodOwnership {
    id: String!
    type: AccessmodAnalysisType!
    status: AccessmodAnalysisStatus!
    name: String!
    author: User!
    owner: AccessmodOwner
    authorizedActions: [AccessmodAnalysisAuthorizedActions!]!
    createdAt: DateTime!
    updatedAt: DateTime!
    population: AccessmodFileset
    frictionSurface: AccessmodFileset
    dem: AccessmodFileset
    healthFacilities: AccessmodFileset
    anisotropic: Boolean
    maxTravelTime: Int
    hfProcessingOrder: String
    geographicCoverage: AccessmodFileset
    catchmentAreas: AccessmodFileset
}
type AccessmodAnalysisPage {
    pageNumber: Int!
    totalPages: Int!
    totalItems: Int!
    items: [AccessmodAnalysis!]!
}
input CreateAccessmodAccessibilityAnalysisInput {
    projectId: String!
    name: String!
}
type CreateAccessmodAccessibilityAnalysisResult {
    success: Boolean!
    analysis: AccessmodAccessibilityAnalysis
    errors: [CreateAccessmodAccessibilityAnalysisError!]!
}
enum CreateAccessmodAccessibilityAnalysisError {
    NAME_DUPLICATE
}
input UpdateAccessmodAccessibilityAnalysisInput {
    id: String!
    name: String
    landCoverId: String
    demId: String
    stackId: String
    stackPriorities: StackPriorities
    transportNetworkId: String
    waterId: String
    barrierId: String
    movingSpeeds: MovingSpeeds
    healthFacilitiesId: String
    invertDirection: Boolean
    maxTravelTime: Int
    waterAllTouched: Boolean
    algorithm: AccessmodAccessibilityAnalysisAlgorithm
    knightMove: Boolean
}
type UpdateAccessmodAccessibilityAnalysisResult {
    success: Boolean!
    analysis: AccessmodAccessibilityAnalysis
    errors: [UpdateAccessmodAccessibilityAnalysisError!]!
}
enum UpdateAccessmodAccessibilityAnalysisError {
    NOT_FOUND
    NAME_DUPLICATE
}
input LaunchAccessmodAnalysisInput {
    id: String!
}
type LaunchAccessmodAnalysisResult {
    success: Boolean!
    analysis: AccessmodAnalysis
    errors: [LaunchAccessmodAnalysisError!]!
}
enum LaunchAccessmodAnalysisError {
    LAUNCH_FAILED
}
input DeleteAccessmodAnalysisInput {
    id: String!
}
type DeleteAccessmodAnalysisResult {
    success: Boolean!
    errors: [DeleteAccessmodAnalysisError!]!
}
enum DeleteAccessmodAnalysisError {
    NOT_FOUND
    DELETE_FAILED
}
extend type Query {
    accessmodAnalysis(id: String): AccessmodAnalysis
    accessmodAnalyses(projectId: String!, page: Int, perPage: Int): AccessmodAnalysisPage!
}
extend type Mutation {
    createAccessmodAccessibilityAnalysis(input: CreateAccessmodAccessibilityAnalysisInput): CreateAccessmodAccessibilityAnalysisResult!
    updateAccessmodAccessibilityAnalysis(input: UpdateAccessmodAccessibilityAnalysisInput): UpdateAccessmodAccessibilityAnalysisResult!
    launchAccessmodAnalysis(input: LaunchAccessmodAnalysisInput): LaunchAccessmodAnalysisResult!
    deleteAccessmodAnalysis(input: DeleteAccessmodAnalysisInput): DeleteAccessmodAnalysisResult!
}
